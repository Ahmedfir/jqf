/*
 * Copyright (c) 2017, University of California, Berkeley
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package jwig.logging;

import janala.logger.inst.Instruction;
import janala.logger.inst.*;

import java.util.concurrent.*;

/**
 * This class is responsible for data-trace logging for an insruction stream
 * generated by a single thread in the application.
 *
 * @author Rohan Padhye
 */
class SingleThreadTracer extends Thread {
    private final BlockingDeque<Instruction> queue = new LinkedBlockingDeque<>();
    private final PrintLogger logger;
    private final Thread tracee;

    /** Creates a new tracer that will print the data-traces of a tracee to a logger. */
    protected SingleThreadTracer(Thread tracee, PrintLogger logger) {
        this.tracee = tracee;
        this.logger = logger;
    }

    /** Spawns a thread tracer for the current thread and returns its reference. */
    protected static SingleThreadTracer spawn(PrintLogger logger) {
        SingleThreadTracer t = new SingleThreadTracer(Thread.currentThread(), logger);
        t.start();
        return t;
    }

    /** Sends an instruction to the tracer for processing. */
    protected void consume(Instruction ins) {
        try {
            queue.putLast(ins);
        } catch (InterruptedException e) {
            this.interrupt(); // This is a bad sign
        }
    }

    /**
     * Retrieves the next yet-unprocessed instruction in FIFO sequeuence.
     *
     * This method blocks for the next instruction up to a fixed timeout.
     * After the timeout, it checks to see if the tracee is alive and if so
     * repeats the timed-block. If the tracee is dead, the tracer is
     * interrupted.
     *
     * */
    protected Instruction next() throws InterruptedException {
        // Keep attempting to get instructions while queue is non-empty or tracee is alive
        while (!queue.isEmpty() || tracee.isAlive()) {
            // Attempt to poll queue with a timeout
            Instruction ins = queue.poll(1, TimeUnit.SECONDS);
            // Return instruction if available, else re-try
            if (ins != null) {
                return ins;
            }
        }
        // If tracee is dead, interrupt this thread
        throw new InterruptedException();
    }


    /** Returns an instruction to the queue for processing (used by lookaheads). */
    protected void restore(Instruction ins) {
        try {
            queue.putFirst(ins);
        } catch (InterruptedException e) {
            this.interrupt(); // This is a bad sign
        }
    }

    @Override
    public void run() {
        try {
            while (true) {
                process();
            }
        } catch (InterruptedException e) {
            // Exit normally
        }
    }

    /** Processes the stream of instructions. */
    private void process() throws InterruptedException {
        Instruction ins = next();
        logger.log(ins.toString());
        if (ins instanceof AALOAD) {
            Instruction la = next();
            if (la instanceof SPECIAL) {
                // ignore
            } else {
                restore(la);
            }
        }
    }
}
